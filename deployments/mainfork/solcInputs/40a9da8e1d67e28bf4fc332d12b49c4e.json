{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "src/interface/IPostageStamp.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.19;\n\ninterface IPostageStamp {\n    function withdraw(address beneficiary) external;\n\n    function validChunkCount() external view returns (uint256);\n\n    function batchOwner(bytes32 _batchId) external view returns (address);\n\n    function batchDepth(bytes32 _batchId) external view returns (uint8);\n\n    function batchBucketDepth(bytes32 _batchId) external view returns (uint8);\n\n    function remainingBalance(bytes32 _batchId) external view returns (uint256);\n\n    function minimumInitialBalancePerChunk() external view returns (uint256);\n\n    function setPrice(uint256 _price) external;\n\n    function batches(\n        bytes32\n    )\n        external\n        view\n        returns (\n            address owner,\n            uint8 depth,\n            uint8 bucketDepth,\n            bool immutableFlag,\n            uint256 normalisedBalance,\n            uint256 lastUpdatedBlockNumber\n        );\n}\n"
    },
    "src/Redistribution.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.19;\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"./Util/TransformedChunkProof.sol\";\nimport \"./Util/ChunkProof.sol\";\nimport \"./Util/Signatures.sol\";\nimport \"./interface/IPostageStamp.sol\";\n\ninterface IPriceOracle {\n    function adjustPrice(uint16 redundancy) external;\n}\n\ninterface IStakeRegistry {\n    function freezeDeposit(bytes32 overlay, uint256 time) external;\n\n    function lastUpdatedBlockNumberOfOverlay(bytes32 overlay) external view returns (uint256);\n\n    function ownerOfOverlay(bytes32 overlay) external view returns (address);\n\n    function stakeOfOverlay(bytes32 overlay) external view returns (uint256);\n}\n\n/**\n * @title Redistribution contract\n * @author The Swarm Authors\n * @dev Implements a Schelling Co-ordination game to form consensus around the Reserve Commitment hash. This takes\n * place in three phases: _commit_, _reveal_ and _claim_.\n *\n * A node, upon establishing that it _isParticipatingInUpcomingRound_, i.e. it's overlay falls within proximity order\n * of its reported depth with the _currentRoundAnchor_, prepares a \"reserve commitment hash\" using the chunks\n * it currently stores in its reserve and calculates the \"storage depth\" (see Bee for details). These values, if calculated\n * honestly, and with the right chunks stored, should be the same for every node in a neighbourhood. This is the Schelling point.\n * Each eligible node can then use these values, together with a random, single use, secret  _revealNonce_ and their\n * _overlay_ as the pre-image values for the obsfucated _commit_, using the _wrapCommit_ method.\n *\n * Once the _commit_ round has elapsed, participating nodes must provide the values used to calculate their obsfucated\n * _commit_ hash, which, once verified for correctness and proximity to the anchor are retained in the _currentReveals_.\n * Nodes that have commited but do not reveal the correct values used to create the pre-image will have their stake\n * \"frozen\" for a period of rounds proportional to their reported depth.\n *\n * During the _reveal_ round, randomness is updated after every successful reveal. Once the reveal round is concluded,\n * the _currentRoundAnchor_ is updated and users can determine if they will be eligible their overlay will be eligible\n * for the next commit phase using _isParticipatingInUpcomingRound_.\n *\n * When the _reveal_ phase has been concluded, the claim phase can begin. At this point, the truth teller and winner\n * are already determined. By calling _isWinner_, an applicant node can run the relevant logic to determine if they have\n * been selected as the beneficiary of this round. When calling _claim_, the current pot from the PostageStamp contract\n * is withdrawn and transferred to that beneficiaries address. Nodes that have revealed values that differ from the truth,\n * have their stakes \"frozen\" for a period of rounds proportional to their reported depth.\n */\n\ncontract Redistribution is AccessControl, Pausable {\n    // ----------------------------- Type declarations ------------------------------\n\n    // An eligible user may commit to an _obfuscatedHash_ during the commit phase...\n    struct Commit {\n        bytes32 overlay;\n        address owner;\n        bool revealed;\n        uint256 stake;\n        bytes32 obfuscatedHash;\n        uint256 revealIndex;\n    }\n    // ...then provide the actual values that are the constituents of the pre-image of the _obfuscatedHash_\n    // during the reveal phase.\n    struct Reveal {\n        bytes32 overlay;\n        address owner;\n        uint8 depth;\n        uint256 stake;\n        uint256 stakeDensity;\n        bytes32 hash;\n    }\n\n    struct ChunkInclusionProof {\n        bytes32[] proofSegments;\n        bytes32 proveSegment;\n        // _RCspan is known for RC 32*32\n\n        // Inclusion proof of transformed address\n        bytes32[] proofSegments2;\n        bytes32 proveSegment2;\n        // proveSegmentIndex2 known from deterministic random selection;\n        uint64 chunkSpan;\n        bytes32[] proofSegments3;\n        //  _proveSegment3 known, is equal _proveSegment2\n        // proveSegmentIndex3 know, is equal _proveSegmentIndex2;\n        // chunkSpan2 is equal to chunkSpan (as the data is the same)\n        //\n        PostageProof postageProof;\n        SOCProof[] socProof;\n    }\n\n    struct SOCProof {\n        address signer; // signer Ethereum address to check against\n        bytes signature;\n        bytes32 identifier; //\n        bytes32 chunkAddr; // wrapped chunk address\n    }\n\n    struct PostageProof {\n        bytes signature;\n        bytes32 postageId;\n        uint64 index;\n        uint64 timeStamp;\n        // address signer; it is provided by the postage stamp contract\n        // bytes32 chunkAddr; it equals to the proveSegment argument\n    }\n\n    // The address of the linked PostageStamp contract.\n    IPostageStamp public PostageContract;\n    // The address of the linked PriceOracle contract.\n    IPriceOracle public OracleContract;\n    // The address of the linked Staking contract.\n    IStakeRegistry public Stakes;\n\n    // Commits for the current round.\n    Commit[] public currentCommits;\n    // Reveals for the current round.\n    Reveal[] public currentReveals;\n\n    // The current anchor that being processed for the reveal and claim phases of the round.\n    bytes32 private currentRevealRoundAnchor;\n\n    // The current random value from which we will random.\n    // inputs for selection of the truth teller and beneficiary.\n    bytes32 private seed;\n\n    // The number of the currently active round phases.\n    uint64 public currentCommitRound;\n    uint64 public currentRevealRound;\n    uint64 public currentClaimRound;\n\n    // Settings for slashing and freezing\n    uint8 private penaltyMultiplierDisagreement = 1;\n    uint8 private penaltyMultiplierNonRevealed = 2;\n\n    // alpha=0.097612 beta=0.0716570 k=16\n    uint256 private sampleMaxValue =\n        1284401000000000000000000000000000000000000000000000000000000000000000000;\n\n    // The reveal of the winner of the last round.\n    Reveal public winner;\n\n    // The length of a round in blocks.\n    uint256 private constant ROUND_LENGTH = 152;\n\n    // The miniumum stake allowed to be staked using the Staking contract.\n    uint64 private constant MIN_STAKE = 100000000000000000;\n\n    // Maximum value of the keccack256 hash.\n    bytes32 private constant MAX_H = 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;\n\n    // Role allowed to pause.\n    bytes32 private immutable PAUSER_ROLE;\n\n    // ----------------------------- Events ------------------------------\n\n    /**\n     * @dev Emitted when the winner of a round is selected in the claim phase\n     */\n    event WinnerSelected(Reveal winner);\n\n    /**\n     * @dev Emitted when the truth oracle of a round is selected in the claim phase.\n     */\n    event TruthSelected(bytes32 hash, uint8 depth);\n\n    // Next two events to be removed after testing phase pending some other usefulness being found.\n    /**\n     * @dev Emits the number of commits being processed by the claim phase.\n     */\n    event CountCommits(uint256 _count);\n\n    /**\n     * @dev Emits the number of reveals being processed by the claim phase.\n     */\n    event CountReveals(uint256 _count);\n\n    /**\n     * @dev Logs that an overlay has committed\n     */\n    event Committed(uint256 roundNumber, bytes32 overlay);\n    /**\n     * @dev Emit from Postagestamp contract valid chunk count at the end of claim\n     */\n    event ChunkCount(uint256 validChunkCount);\n\n    /**\n     * @dev Bytes32 anhor of current reveal round\n     */\n    event CurrentRevealAnchor(uint256 roundNumber, bytes32 anchor);\n\n    /**\n     * @dev Logs that an overlay has revealed\n     */\n    event Revealed(\n        uint256 roundNumber,\n        bytes32 overlay,\n        uint256 stake,\n        uint256 stakeDensity,\n        bytes32 reserveCommitment,\n        uint8 depth\n    );\n\n    /**\n     * @dev Logs for inclusion proof\n     */\n    event transformedChunkAddressFromInclusionProof(uint256 indexInRC, bytes32 chunkAddress);\n\n    // ----------------------------- Errors ------------------------------\n\n    error NotCommitPhase(); // Game is not in commit phase\n    error NoCommitsReceived(); // Round didn't receive any commits\n    error PhaseLastBlock(); // We don't permit commits in last block of the phase\n    error BelowMinimumStake(); // Node participating in game has stake below minimum treshold\n    error CommitRoundOver(); // Commit phase in this round is over\n    error CommitRoundNotStarted(); // Commit phase in this round has not started yet\n    error NotMatchingOwner(); // Sender of commit is not matching the overlay address\n    error MustStake2Rounds(); // Before entering the game node must stake 2 rounds prior\n    error WrongPhase(); // Checking in wrong phase, need to check duing claim phase of current round for next round or commit in current round\n    error AlreadyCommited(); // Node already commited in this round\n    error NotRevealPhase(); // Game is not in reveal phase\n    error OutOfDepthReveal(bytes32); // Anchor is out of reported depth in Reveal phase, anchor data available as argument\n    error OutOfDepthClaim(uint8); // Anchor is out of reported depth in Claim phase, entryProof index is argument\n    error OutOfDepth(); // Anchor is out of reported depth\n    error AlreadyRevealed(); // Node already revealed\n    error NoMatchingCommit(); // No matching commit and hash\n    error NotClaimPhase(); // Game is not in the claim phase\n    error NoReveals(); // Round did not receive any reveals\n    error FirstRevealDone(); // We don't want to return value after first reveal\n    error AlreadyClaimed(); // This round was already claimed\n    error NotAdmin(); // Caller of trx is not admin\n    error OnlyPauser(); // Only account with pauser role can call pause/unpause\n    error SocVerificationFailed(bytes32); // Soc verification failed for this element\n    error SocCalcNotMatching(bytes32); // Soc address calculation does not match with the witness\n    error IndexOutsideSet(bytes32); // Stamp available: index resides outside of the valid index set\n    error SigRecoveryFailed(bytes32); // Stamp authorized: signature recovery failed for element\n    error BatchDoesNotExist(bytes32); // Stamp alive: batch remaining balance validation failed for attached stamp\n    error BucketDiffers(bytes32); // Stamp aligned: postage bucket differs from address bucket\n    error InclusionProofFailed(uint8, bytes32);\n    // 1 = RC inclusion proof failed for element\n    // 2 = First sister segment in data must match,\n    // 3 = Inclusion proof failed for original address of element\n    // 4 = Inclusion proof failed for transformed address of element\n    error RandomElementCheckFailed(); // Random element order check failed\n    error LastElementCheckFailed(); // Last element order check failed\n    error ReserveCheckFailed(bytes32 trALast); // Reserve size estimation check failed\n\n    // ----------------------------- CONSTRUCTOR ------------------------------\n\n    /**\n     * @param staking the address of the linked Staking contract.\n     * @param postageContract the address of the linked PostageStamp contract.\n     * @param oracleContract the address of the linked PriceOracle contract.\n     */\n    constructor(address staking, address postageContract, address oracleContract, address multisig) {\n        Stakes = IStakeRegistry(staking);\n        PostageContract = IPostageStamp(postageContract);\n        OracleContract = IPriceOracle(oracleContract);\n        PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n        _setupRole(DEFAULT_ADMIN_ROLE, multisig);\n        _setupRole(PAUSER_ROLE, msg.sender);\n    }\n\n    ////////////////////////////////////////\n    //           STATE CHANGING           //\n    ////////////////////////////////////////\n\n    /**\n     * @notice Begin application for a round if eligible. Commit a hashed value for which the pre-image will be\n     * subsequently revealed.\n     * @dev If a node's overlay is _inProximity_(_depth_) of the _currentRoundAnchor_, that node may compute an\n     * _obfuscatedHash_ by providing their _overlay_, reported storage _depth_, reserve commitment _hash_ and a\n     * randomly generated, and secret _revealNonce_ to the _wrapCommit_ method.\n     * @param _obfuscatedHash The calculated hash resultant of the required pre-image values.\n     * @param _overlay The overlay referenced in the pre-image. Must be staked by at least the minimum value,\n     * and be derived from the same key pair as the message sender.\n     */\n    function commit(bytes32 _obfuscatedHash, bytes32 _overlay, uint64 _roundNumber) external whenNotPaused {\n        uint64 cr = currentRound();\n        uint256 nstake = Stakes.stakeOfOverlay(_overlay);\n\n        if (!currentPhaseCommit()) {\n            revert NotCommitPhase();\n        }\n        if (block.number % ROUND_LENGTH == (ROUND_LENGTH / 4) - 1) {\n            revert PhaseLastBlock();\n        }\n\n        if (cr > _roundNumber) {\n            revert CommitRoundOver();\n        }\n\n        if (cr < _roundNumber) {\n            revert CommitRoundNotStarted();\n        }\n\n        if (nstake < MIN_STAKE) {\n            revert BelowMinimumStake();\n        }\n\n        if (Stakes.ownerOfOverlay(_overlay) != msg.sender) {\n            revert NotMatchingOwner();\n        }\n\n        if (Stakes.lastUpdatedBlockNumberOfOverlay(_overlay) >= block.number - 2 * ROUND_LENGTH) {\n            revert MustStake2Rounds();\n        }\n\n        // if we are in a new commit phase, reset the array of commits and\n        // set the currentCommitRound to be the current one\n        if (cr != currentCommitRound) {\n            delete currentCommits;\n            currentCommitRound = cr;\n        }\n\n        uint256 commitsArrayLength = currentCommits.length;\n\n        for (uint256 i = 0; i < commitsArrayLength; ) {\n            if (currentCommits[i].overlay == _overlay) {\n                revert AlreadyCommited();\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        currentCommits.push(\n            Commit({\n                overlay: _overlay,\n                owner: msg.sender,\n                revealed: false,\n                stake: nstake,\n                obfuscatedHash: _obfuscatedHash,\n                revealIndex: 0\n            })\n        );\n\n        emit Committed(_roundNumber, _overlay);\n    }\n\n    /**\n     * @notice Reveal the pre-image values used to generate commit provided during this round's commit phase.\n     * @param _overlay The overlay address of the applicant.\n     * @param _depth The reported depth.\n     * @param _hash The reserve commitment hash.\n     * @param _revealNonce The nonce used to generate the commit that is being revealed.\n     */\n    function reveal(bytes32 _overlay, uint8 _depth, bytes32 _hash, bytes32 _revealNonce) external whenNotPaused {\n        uint64 cr = currentRound();\n\n        if (_depth < currentMinimumDepth()) {\n            revert OutOfDepth();\n        }\n\n        if (!currentPhaseReveal()) {\n            revert NotRevealPhase();\n        }\n\n        if (cr != currentCommitRound) {\n            revert NoCommitsReceived();\n        }\n\n        if (cr != currentRevealRound) {\n            currentRevealRoundAnchor = currentRoundAnchor();\n            delete currentReveals;\n            // We set currentRevealRound ONLY after we set current anchor\n            currentRevealRound = cr;\n            emit CurrentRevealAnchor(cr, currentRevealRoundAnchor);\n            updateRandomness();\n        }\n\n        bytes32 obfuscatedHash = wrapCommit(_overlay, _depth, _hash, _revealNonce);\n        uint256 id = findCommit(_overlay, obfuscatedHash);\n        Commit memory revealedCommit = currentCommits[id];\n\n        // Check that commit is in proximity of the current anchor\n        if (!inProximity(revealedCommit.overlay, currentRevealRoundAnchor, _depth)) {\n            revert OutOfDepthReveal(currentRevealRoundAnchor);\n        }\n        // Check that the commit has not already been revealed\n        if (revealedCommit.revealed) {\n            revert AlreadyRevealed();\n        }\n\n        currentCommits[id].revealed = true;\n        currentCommits[id].revealIndex = currentReveals.length;\n\n        currentReveals.push(\n            Reveal({\n                overlay: revealedCommit.overlay,\n                owner: revealedCommit.owner,\n                depth: _depth,\n                stake: revealedCommit.stake,\n                stakeDensity: revealedCommit.stake * uint256(2 ** _depth),\n                hash: _hash\n            })\n        );\n\n        emit Revealed(\n            cr,\n            revealedCommit.overlay,\n            revealedCommit.stake,\n            revealedCommit.stake * uint256(2 ** _depth),\n            _hash,\n            _depth\n        );\n    }\n\n    /**\n     * @notice Helper function to get this round truth\n     * @dev\n     */\n    function claim(\n        ChunkInclusionProof calldata entryProof1,\n        ChunkInclusionProof calldata entryProof2,\n        ChunkInclusionProof calldata entryProofLast\n    ) external whenNotPaused {\n        winnerSelection();\n\n        Reveal memory winnerSelected = winner;\n        uint256 indexInRC1;\n        uint256 indexInRC2;\n        bytes32 _currentRevealRoundAnchor = currentRevealRoundAnchor;\n        bytes32 _seed = seed;\n\n        // rand(14)\n        indexInRC1 = uint256(_seed) % 15;\n        // rand(13)\n        indexInRC2 = uint256(_seed) % 14;\n        if (indexInRC2 >= indexInRC1) {\n            indexInRC2++;\n        }\n\n        if (!inProximity(entryProofLast.proveSegment, _currentRevealRoundAnchor, winnerSelected.depth)) {\n            revert OutOfDepthClaim(3);\n        }\n\n        inclusionFunction(entryProofLast, 30);\n        stampFunction(entryProofLast);\n        socFunction(entryProofLast);\n\n        if (!inProximity(entryProof1.proveSegment, _currentRevealRoundAnchor, winnerSelected.depth)) {\n            revert OutOfDepthClaim(2);\n        }\n\n        inclusionFunction(entryProof1, indexInRC1 * 2);\n        stampFunction(entryProof1);\n        socFunction(entryProof1);\n\n        if (!inProximity(entryProof2.proveSegment, _currentRevealRoundAnchor, winnerSelected.depth)) {\n            revert OutOfDepthClaim(1);\n        }\n\n        inclusionFunction(entryProof2, indexInRC2 * 2);\n        stampFunction(entryProof2);\n        socFunction(entryProof2);\n\n        checkOrder(\n            indexInRC1,\n            indexInRC2,\n            entryProof1.proofSegments[0],\n            entryProof2.proofSegments[0],\n            entryProofLast.proofSegments[0]\n        );\n\n        estimateSize(entryProofLast.proofSegments[0]);\n\n        PostageContract.withdraw(winnerSelected.owner);\n        emit WinnerSelected(winnerSelected);\n        emit ChunkCount(PostageContract.validChunkCount());\n    }\n\n    function winnerSelection() internal {\n        uint64 cr = currentRound();\n\n        if (!currentPhaseClaim()) {\n            revert NotClaimPhase();\n        }\n\n        if (cr != currentRevealRound) {\n            revert NoReveals();\n        }\n\n        if (cr <= currentClaimRound) {\n            revert AlreadyClaimed();\n        }\n\n        uint256 currentWinnerSelectionSum = 0;\n        uint256 redundancyCount = 0;\n        bytes32 randomNumber;\n        uint256 randomNumberTrunc;\n\n        bytes32 truthRevealedHash;\n        uint8 truthRevealedDepth;\n        uint256 currentCommitsLength = currentCommits.length;\n\n        emit CountCommits(currentCommitsLength);\n        emit CountReveals(currentReveals.length);\n\n        (truthRevealedHash, truthRevealedDepth) = getCurrentTruth();\n        emit TruthSelected(truthRevealedHash, truthRevealedDepth);\n        string memory winnerSelectionAnchor = currentWinnerSelectionAnchor();\n\n        for (uint256 i = 0; i < currentCommitsLength; ) {\n            Commit memory currentCommit = currentCommits[i];\n            uint256 revIndex = currentCommit.revealIndex;\n            Reveal memory currentReveal = currentReveals[revIndex];\n\n            // Select winner with valid truth\n            if (\n                currentCommit.revealed &&\n                truthRevealedHash == currentReveal.hash &&\n                truthRevealedDepth == currentReveal.depth\n            ) {\n                currentWinnerSelectionSum += currentReveal.stakeDensity;\n                randomNumber = keccak256(abi.encodePacked(winnerSelectionAnchor, redundancyCount));\n                randomNumberTrunc = uint256(randomNumber & MAX_H);\n\n                if (randomNumberTrunc * currentWinnerSelectionSum < currentReveal.stakeDensity * (uint256(MAX_H) + 1)) {\n                    winner = currentReveal;\n                }\n\n                redundancyCount++;\n            }\n\n            // Freeze deposit if any truth is false\n            if (\n                currentCommit.revealed &&\n                (truthRevealedHash != currentReveal.hash || truthRevealedDepth != currentReveal.depth)\n            ) {\n                Stakes.freezeDeposit(\n                    currentReveal.overlay,\n                    penaltyMultiplierDisagreement * ROUND_LENGTH * uint256(2 ** truthRevealedDepth)\n                );\n            }\n\n            // Slash deposits if revealed is false\n            if (!currentCommit.revealed) {\n                // slash in later phase (ph5)\n                // Stakes.slashDeposit(currentCommits[i].overlay, currentCommits[i].stake);\n                Stakes.freezeDeposit(\n                    currentCommit.overlay,\n                    penaltyMultiplierNonRevealed * ROUND_LENGTH * uint256(2 ** truthRevealedDepth)\n                );\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        OracleContract.adjustPrice(uint16(redundancyCount));\n        currentClaimRound = cr;\n    }\n\n    function inclusionFunction(ChunkInclusionProof calldata entryProof, uint256 indexInRC) internal {\n        uint256 randomChunkSegmentIndex = uint256(seed) % 128;\n        bytes32 calculatedTransformedAddr = TransformedBMTChunk.transformedChunkAddressFromInclusionProof(\n            entryProof.proofSegments3,\n            entryProof.proveSegment2,\n            randomChunkSegmentIndex,\n            entryProof.chunkSpan,\n            currentRevealRoundAnchor\n        );\n\n        emit transformedChunkAddressFromInclusionProof(indexInRC, calculatedTransformedAddr);\n\n        if (\n            winner.hash !=\n            BMTChunk.chunkAddressFromInclusionProof(\n                entryProof.proofSegments,\n                entryProof.proveSegment,\n                indexInRC,\n                32 * 32\n            )\n        ) {\n            revert InclusionProofFailed(1, calculatedTransformedAddr);\n        }\n\n        if (entryProof.proofSegments2[0] != entryProof.proofSegments3[0]) {\n            revert InclusionProofFailed(2, calculatedTransformedAddr);\n        }\n\n        bytes32 originalAddress = entryProof.socProof.length > 0\n            ? entryProof.socProof[0].chunkAddr // soc attestation in socFunction\n            : entryProof.proveSegment;\n\n        if (\n            originalAddress !=\n            BMTChunk.chunkAddressFromInclusionProof(\n                entryProof.proofSegments2,\n                entryProof.proveSegment2,\n                randomChunkSegmentIndex,\n                entryProof.chunkSpan\n            )\n        ) {\n            revert InclusionProofFailed(3, calculatedTransformedAddr);\n        }\n\n        // In case of SOC, the transformed address is hashed together with its address in the sample\n        if (entryProof.socProof.length > 0) {\n            calculatedTransformedAddr = keccak256(\n                abi.encode(\n                    entryProof.proveSegment, // SOC address\n                    calculatedTransformedAddr\n                )\n            );\n        }\n\n        if (entryProof.proofSegments[0] != calculatedTransformedAddr) {\n            revert InclusionProofFailed(4, calculatedTransformedAddr);\n        }\n    }\n\n    /**\n     * @notice Set freezing parameters\n     */\n    function setFreezingParams(uint8 _penaltyMultiplierDisagreement, uint8 _penaltyMultiplierNonRevealed) external {\n        if (!hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n            revert NotAdmin();\n        }\n\n        penaltyMultiplierDisagreement = _penaltyMultiplierDisagreement;\n        penaltyMultiplierNonRevealed = _penaltyMultiplierNonRevealed;\n    }\n\n    /**\n     * @notice changes the max sample value used for reserve estimation\n     */\n    function setSampleMaxValue(uint256 _sampleMaxValue) external {\n        if (!hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n            revert NotAdmin();\n        }\n\n        sampleMaxValue = _sampleMaxValue;\n    }\n\n    /**\n     * @notice Updates the source of randomness. Uses block.difficulty in pre-merge chains, this is substituted\n     * to block.prevrandao in post merge chains.\n     */\n    function updateRandomness() private {\n        seed = keccak256(abi.encode(seed, block.prevrandao));\n    }\n\n    /**\n    * @dev Pause the contract. The contract is provably stopped by renouncing\n     the pauser role and the admin role after pausing, can only be called by the `PAUSER`\n     */\n    function pause() public {\n        if (!hasRole(PAUSER_ROLE, msg.sender)) {\n            revert OnlyPauser();\n        }\n\n        _pause();\n    }\n\n    /**\n     * @dev Unpause the contract, can only be called by the pauser when paused\n     */\n    function unPause() public {\n        if (!hasRole(PAUSER_ROLE, msg.sender)) {\n            revert OnlyPauser();\n        }\n        _unpause();\n    }\n\n    ////////////////////////////////////////\n    //            STATE READING           //\n    ////////////////////////////////////////\n\n    // ----------------------------- Anchor calculations ------------------------------\n\n    /**\n     * @notice Returns the current random seed which is used to determine later utilised random numbers.\n     * If rounds have elapsed without reveals, hash the seed with an incremented nonce to produce a new\n     * random seed and hence a new round anchor.\n     */\n    function currentSeed() public view returns (bytes32) {\n        uint64 cr = currentRound();\n        bytes32 currentSeedValue = seed;\n\n        if (cr > currentRevealRound + 1) {\n            uint256 difference = cr - currentRevealRound - 1;\n            currentSeedValue = keccak256(abi.encodePacked(currentSeedValue, difference));\n        }\n\n        return currentSeedValue;\n    }\n\n    /**\n     * @notice Returns the seed which will become current once the next commit phase begins.\n     * Used to determine what the next round's anchor will be.\n     */\n    function nextSeed() public view returns (bytes32) {\n        uint64 cr = currentRound() + 1;\n        bytes32 currentSeedValue = seed;\n\n        if (cr > currentRevealRound + 1) {\n            uint256 difference = cr - currentRevealRound - 1;\n            currentSeedValue = keccak256(abi.encodePacked(currentSeedValue, difference));\n        }\n\n        return currentSeedValue;\n    }\n\n    /**\n     * @notice The random value used to choose the selected truth teller.\n     */\n    function currentTruthSelectionAnchor() private view returns (string memory) {\n        if (!currentPhaseClaim()) {\n            revert NotClaimPhase();\n        }\n\n        uint64 cr = currentRound();\n        if (cr != currentRevealRound) {\n            revert NoReveals();\n        }\n\n        return string(abi.encodePacked(seed, \"0\"));\n    }\n\n    /**\n     * @notice The random value used to choose the selected beneficiary.\n     */\n    function currentWinnerSelectionAnchor() private view returns (string memory) {\n        if (!currentPhaseClaim()) {\n            revert NotClaimPhase();\n        }\n        uint64 cr = currentRound();\n        if (cr != currentRevealRound) {\n            revert NoReveals();\n        }\n\n        return string(abi.encodePacked(seed, \"1\"));\n    }\n\n    /**\n     * @notice The anchor used to determine eligibility for the current round.\n     * @dev A node must be within proximity order of less than or equal to the storage depth they intend to report.\n     */\n    function currentRoundAnchor() public view returns (bytes32 returnVal) {\n        // This will be called in reveal phase and set as currentRevealRoundAnchor or in\n        // commit phase when checking eligibility for next round by isParticipatingInUpcomingRound\n        if (currentPhaseCommit() || (currentRound() > currentRevealRound && !currentPhaseClaim())) {\n            return currentSeed();\n        }\n\n        // This will be called by isParticipatingInUpcomingRound check in claim phase\n        if (currentPhaseClaim()) {\n            return nextSeed();\n        }\n\n        // Without this, this function will output 0x0 after first reveal which is value and we prefere it reverts\n        if (currentPhaseReveal() && currentRound() == currentRevealRound) {\n            revert FirstRevealDone();\n        }\n    }\n\n    /**\n     * @notice Returns true if an overlay address _A_ is within proximity order _minimum_ of _B_.\n     * @param A An overlay address to compare.\n     * @param B An overlay address to compare.\n     * @param minimum Minimum proximity order.\n     */\n    function inProximity(bytes32 A, bytes32 B, uint8 minimum) public pure returns (bool) {\n        if (minimum == 0) {\n            return true;\n        }\n        return uint256(A ^ B) < uint256(2 ** (256 - minimum));\n    }\n\n    // ----------------------------- Commit ------------------------------\n\n    /**\n     * @notice The number of the current round.\n     */\n    function currentRound() public view returns (uint64) {\n        return uint64(block.number / ROUND_LENGTH);\n    }\n\n    /**\n     * @notice Returns true if current block is during commit phase.\n     */\n    function currentPhaseCommit() public view returns (bool) {\n        if (block.number % ROUND_LENGTH < ROUND_LENGTH / 4) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @notice Determine if a the owner of a given overlay can participate in the upcoming round.\n     * @param overlay The overlay address of the applicant.\n     * @param depth The storage depth the applicant intends to report.\n     */\n    function isParticipatingInUpcomingRound(bytes32 overlay, uint8 depth) public view returns (bool) {\n        if (currentPhaseReveal()) {\n            revert WrongPhase();\n        }\n\n        if (Stakes.lastUpdatedBlockNumberOfOverlay(overlay) >= block.number - 2 * ROUND_LENGTH) {\n            revert MustStake2Rounds();\n        }\n\n        if (Stakes.stakeOfOverlay(overlay) < MIN_STAKE) {\n            revert BelowMinimumStake();\n        }\n\n        return inProximity(overlay, currentRoundAnchor(), depth);\n    }\n\n    // ----------------------------- Reveal ------------------------------\n\n    /**\n     * @notice Returns minimum depth reveal has to have to participate in this round\n     */\n    function currentMinimumDepth() public view returns (uint8) {\n        // We are checking value in reveal phase, as the currentCommitRound is set to the current round\n        // but the currentClaimRound is still set to the last time claim was made\n        // We add 1 to ensure that for the next round the minimum depth is the same as last winner depth\n\n        uint256 difference = currentCommitRound - currentClaimRound;\n        uint8 skippedRounds = uint8(difference > 254 ? 254 : difference) + 1;\n\n        uint8 lastWinnerDepth = winner.depth;\n\n        // We ensure that skippedRounds is not bigger than lastWinnerDepth, because of overflow\n        return skippedRounds >= lastWinnerDepth ? 0 : lastWinnerDepth - skippedRounds;\n    }\n\n    /**\n     * @notice Helper function to get this node reveal in commits\n     * @dev\n     */\n    function findCommit(bytes32 _overlay, bytes32 _obfuscatedHash) internal view returns (uint256) {\n        for (uint256 i = 0; i < currentCommits.length; ) {\n            if (currentCommits[i].overlay == _overlay && _obfuscatedHash == currentCommits[i].obfuscatedHash) {\n                return i;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        revert NoMatchingCommit();\n    }\n\n    /**\n     * @notice Hash the pre-image values to the obsfucated hash.\n     * @dev _revealNonce_ must be randomly generated, used once and kept secret until the reveal phase.\n     * @param _overlay The overlay address of the applicant.\n     * @param _depth The reported depth.\n     * @param _hash The reserve commitment hash.\n     * @param revealNonce A random, single use, secret nonce.\n     */\n    function wrapCommit(\n        bytes32 _overlay,\n        uint8 _depth,\n        bytes32 _hash,\n        bytes32 revealNonce\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_overlay, _depth, _hash, revealNonce));\n    }\n\n    /**\n     * @notice Returns true if current block is during reveal phase.\n     */\n    function currentPhaseReveal() public view returns (bool) {\n        uint256 number = block.number % ROUND_LENGTH;\n        if (number >= ROUND_LENGTH / 4 && number < ROUND_LENGTH / 2) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @notice Returns true if current block is during reveal phase.\n     */\n    function currentRoundReveals() public view returns (Reveal[] memory) {\n        if (!currentPhaseClaim()) {\n            revert NotClaimPhase();\n        }\n        uint64 cr = currentRound();\n        if (cr != currentRevealRound) {\n            revert NoReveals();\n        }\n\n        return currentReveals;\n    }\n\n    // ----------------------------- Claim  ------------------------------\n\n    /**\n     * @notice Returns true if current block is during claim phase.\n     */\n    function currentPhaseClaim() public view returns (bool) {\n        if (block.number % ROUND_LENGTH >= ROUND_LENGTH / 2) {\n            return true;\n        }\n        return false;\n    }\n\n    function getCurrentTruth() internal view returns (bytes32 Hash, uint8 Depth) {\n        uint256 currentSum;\n        bytes32 randomNumber;\n        uint256 randomNumberTrunc;\n\n        bytes32 truthRevealedHash;\n        uint8 truthRevealedDepth;\n        uint256 revIndex;\n        string memory truthSelectionAnchor = currentTruthSelectionAnchor();\n        uint256 commitsArrayLength = currentCommits.length;\n\n        for (uint256 i = 0; i < commitsArrayLength; ) {\n            if (currentCommits[i].revealed) {\n                revIndex = currentCommits[i].revealIndex;\n                currentSum += currentReveals[revIndex].stakeDensity;\n                randomNumber = keccak256(abi.encodePacked(truthSelectionAnchor, i));\n                randomNumberTrunc = uint256(randomNumber & MAX_H);\n\n                // question is whether randomNumber / MAX_H < probability\n                // where probability is stakeDensity / currentSum\n                // to avoid resorting to floating points all divisions should be\n                // simplified with multiplying both sides (as long as divisor > 0)\n                // randomNumber / (MAX_H + 1) < stakeDensity / currentSum\n                // ( randomNumber / (MAX_H + 1) ) * currentSum < stakeDensity\n                // randomNumber * currentSum < stakeDensity * (MAX_H + 1)\n                if (randomNumberTrunc * currentSum < currentReveals[revIndex].stakeDensity * (uint256(MAX_H) + 1)) {\n                    truthRevealedHash = currentReveals[revIndex].hash;\n                    truthRevealedDepth = currentReveals[revIndex].depth;\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        return (truthRevealedHash, truthRevealedDepth);\n    }\n\n    /**\n     * @notice Determine if a the owner of a given overlay will be the beneficiary of the claim phase.\n     * @param _overlay The overlay address of the applicant.\n     */\n    function isWinner(bytes32 _overlay) public view returns (bool) {\n        if (!currentPhaseClaim()) {\n            revert NotClaimPhase();\n        }\n\n        uint64 cr = currentRound();\n        if (cr != currentRevealRound) {\n            revert NoReveals();\n        }\n\n        if (cr <= currentClaimRound) {\n            revert AlreadyClaimed();\n        }\n\n        uint256 currentWinnerSelectionSum;\n        bytes32 winnerIs;\n        bytes32 randomNumber;\n        uint256 randomNumberTrunc;\n        bytes32 truthRevealedHash;\n        uint8 truthRevealedDepth;\n        uint256 revIndex;\n        string memory winnerSelectionAnchor = currentWinnerSelectionAnchor();\n        uint256 redundancyCount = 0;\n\n        // Get current truth\n        (truthRevealedHash, truthRevealedDepth) = getCurrentTruth();\n        uint256 commitsArrayLength = currentCommits.length;\n\n        for (uint256 i = 0; i < commitsArrayLength; ) {\n            revIndex = currentCommits[i].revealIndex;\n\n            // Deterministically read winner\n            if (\n                currentCommits[i].revealed &&\n                truthRevealedHash == currentReveals[revIndex].hash &&\n                truthRevealedDepth == currentReveals[revIndex].depth\n            ) {\n                currentWinnerSelectionSum += currentReveals[revIndex].stakeDensity;\n                randomNumber = keccak256(abi.encodePacked(winnerSelectionAnchor, redundancyCount));\n                randomNumberTrunc = uint256(randomNumber & MAX_H);\n\n                if (\n                    randomNumberTrunc * currentWinnerSelectionSum <\n                    currentReveals[revIndex].stakeDensity * (uint256(MAX_H) + 1)\n                ) {\n                    winnerIs = currentReveals[revIndex].overlay;\n                }\n\n                redundancyCount++;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        return (winnerIs == _overlay);\n    }\n\n    // ----------------------------- Claim verifications  ------------------------------\n\n    function socFunction(ChunkInclusionProof calldata entryProof) internal pure {\n        if (entryProof.socProof.length == 0) return;\n\n        if (\n            !Signatures.socVerify(\n                entryProof.socProof[0].signer, // signer Ethereum address to check against\n                entryProof.socProof[0].signature,\n                entryProof.socProof[0].identifier,\n                entryProof.socProof[0].chunkAddr\n            )\n        ) {\n            revert SocVerificationFailed(entryProof.socProof[0].chunkAddr);\n        }\n\n        if (\n            calculateSocAddress(entryProof.socProof[0].identifier, entryProof.socProof[0].signer) !=\n            entryProof.proveSegment\n        ) {\n            revert SocCalcNotMatching(entryProof.socProof[0].chunkAddr);\n        }\n    }\n\n    function stampFunction(ChunkInclusionProof calldata entryProof) internal view {\n        // authentic\n        (address batchOwner, uint8 batchDepth, uint8 bucketDepth, , , ) = PostageContract.batches(\n            entryProof.postageProof.postageId\n        );\n\n        // alive\n        if (batchOwner == address(0)) {\n            revert BatchDoesNotExist(entryProof.postageProof.postageId); // Batch does not exist or expired\n        }\n\n        uint32 postageIndex = getPostageIndex(entryProof.postageProof.index);\n        uint256 maxPostageIndex = postageStampIndexCount(batchDepth, bucketDepth);\n        // available\n        if (postageIndex >= maxPostageIndex) {\n            revert IndexOutsideSet(entryProof.postageProof.postageId);\n        }\n\n        // aligned\n        uint64 postageBucket = getPostageBucket(entryProof.postageProof.index);\n        uint64 addressBucket = addressToBucket(entryProof.proveSegment, bucketDepth);\n        if (postageBucket != addressBucket) {\n            revert BucketDiffers(entryProof.postageProof.postageId);\n        }\n\n        // authorized\n        if (\n            !Signatures.postageVerify(\n                batchOwner,\n                entryProof.postageProof.signature,\n                entryProof.proveSegment,\n                entryProof.postageProof.postageId,\n                entryProof.postageProof.index,\n                entryProof.postageProof.timeStamp\n            )\n        ) {\n            revert SigRecoveryFailed(entryProof.postageProof.postageId);\n        }\n    }\n\n    function addressToBucket(bytes32 swarmAddress, uint8 bucketDepth) internal pure returns (uint32) {\n        uint32 prefix = uint32(uint256(swarmAddress) >> (256 - 32));\n        return prefix >> (32 - bucketDepth);\n    }\n\n    function postageStampIndexCount(uint8 postageDepth, uint8 bucketDepth) internal pure returns (uint256) {\n        return 1 << (postageDepth - bucketDepth);\n    }\n\n    function getPostageIndex(uint64 signedIndex) internal pure returns (uint32) {\n        return uint32(signedIndex);\n    }\n\n    function getPostageBucket(uint64 signedIndex) internal pure returns (uint64) {\n        return uint32(signedIndex >> 32);\n    }\n\n    function calculateSocAddress(bytes32 identifier, address signer) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(identifier, signer));\n    }\n\n    function checkOrder(uint256 a, uint256 b, bytes32 trA1, bytes32 trA2, bytes32 trALast) internal pure {\n        if (a < b) {\n            if (uint256(trA1) >= uint256(trA2)) {\n                revert RandomElementCheckFailed();\n            }\n            if (uint256(trA2) >= uint256(trALast)) {\n                revert LastElementCheckFailed();\n            }\n        } else {\n            if (uint256(trA2) >= uint256(trA1)) {\n                revert RandomElementCheckFailed();\n            }\n            if (uint256(trA1) >= uint256(trALast)) {\n                revert LastElementCheckFailed();\n            }\n        }\n    }\n\n    function estimateSize(bytes32 trALast) internal view {\n        if (uint256(trALast) >= sampleMaxValue) {\n            revert ReserveCheckFailed(trALast);\n        }\n    }\n}\n"
    },
    "src/Util/ChunkProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nlibrary BMTChunk {\n    // max chunk payload size\n    uint256 public constant MAX_CHUNK_PAYLOAD_SIZE = 4096;\n    // segment byte size\n    uint256 public constant SEGMENT_SIZE = 32;\n\n    /**\n     * @notice          Changes the endianness of a uint64.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint64(uint64 _b) public pure returns (uint64) {\n        uint256 v = _b;\n\n        // swap bytes\n        v =\n            ((v >> 8) & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\n        // swap 2-byte long pairs\n        v =\n            ((v >> 16) & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\n        // swap 4-byte long pairs\n        v =\n            ((v >> 32) & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\n\n        return uint64(v);\n    }\n\n    /** Calculates the root hash from the provided inclusion proof segments and its corresponding segment index\n     * @param _proofSegments Proof segments.\n     * @param _proveSegment Segment to prove.\n     * @param _proveSegmentIndex Prove segment index\n     * @return _calculatedHash chunk hash\n     */\n    function rootHashFromInclusionProof(\n        bytes32[] memory _proofSegments,\n        bytes32 _proveSegment,\n        uint256 _proveSegmentIndex\n    ) internal pure returns (bytes32 _calculatedHash) {\n        _calculatedHash = _proveSegment;\n        for (uint256 i = 0; i < _proofSegments.length; i++) {\n            bool mergeFromRight = _proveSegmentIndex % 2 == 0;\n            _calculatedHash = mergeSegment(_calculatedHash, _proofSegments[i], mergeFromRight);\n            _proveSegmentIndex >>= 1;\n        }\n        return _calculatedHash;\n    }\n\n    /**\n     * Calculate the chunk address from the Binary Merkle Tree of the chunk data\n     *\n     * The BMT chunk address is the hash of the 8 byte span and the root\n     * hash of a binary Merkle tree (BMT) built on the 32-byte segments\n     * of the underlying data.\n     * @param _proofSegments Proof segments.\n     * @param _proveSegment Segment to prove.\n     * @param _proveSegmentIndex Prove segment index\n     * @param _chunkSpan chunk bytes length\n     * @return _chunkHash chunk hash\n     */\n    function chunkAddressFromInclusionProof(\n        bytes32[] memory _proofSegments,\n        bytes32 _proveSegment,\n        uint256 _proveSegmentIndex,\n        uint64 _chunkSpan\n    ) internal pure returns (bytes32) {\n        bytes32 rootHash = rootHashFromInclusionProof(_proofSegments, _proveSegment, _proveSegmentIndex);\n        return keccak256(abi.encodePacked(reverseUint64(_chunkSpan), rootHash));\n    }\n\n    function mergeSegment(\n        bytes32 _calculatedHash,\n        bytes32 _proofSegment,\n        bool mergeFromRight\n    ) internal pure returns (bytes32 res) {\n        if (mergeFromRight) {\n            res = keccak256(abi.encode(_calculatedHash, _proofSegment));\n        } else {\n            res = keccak256(abi.encode(_proofSegment, _calculatedHash));\n        }\n        return res;\n    }\n}\n"
    },
    "src/Util/Signatures.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nlibrary Signatures {\n    error InvalidSignatureLength();\n\n    /** Hash of the message to sign */\n    function getPostageMessageHash(\n        bytes32 _chunkAddr,\n        bytes32 _batchId,\n        uint64 _index,\n        uint64 _timeStamp\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_chunkAddr, _batchId, _index, _timeStamp));\n    }\n\n    function postageVerify(\n        address _signer, // signer Ethereum address to check against\n        bytes memory _signature,\n        bytes32 _chunkAddr,\n        bytes32 _postageId,\n        uint64 _index,\n        uint64 _timeStamp\n    ) internal pure returns (bool) {\n        bytes32 messageHash = getPostageMessageHash(_chunkAddr, _postageId, _index, _timeStamp);\n        bytes32 ethMessageHash = getEthSignedMessageHash(messageHash);\n\n        return recoverSigner(ethMessageHash, _signature) == _signer;\n    }\n\n    function getEthSignedMessageHash(bytes32 _messageHash) internal pure returns (bytes32) {\n        /*\n        Signature is produced by signing a keccak256 hash with the following format:\n        \"\\x19Ethereum Signed Message\\n\" + len(msg) + msg\n        */\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _messageHash));\n    }\n\n    function recoverSigner(\n        bytes32 _ethSignedMessageHash, // it has to be prefixed message: https://ethereum.stackexchange.com/questions/19582/does-ecrecover-in-solidity-expects-the-x19ethereum-signed-message-n-prefix/21037\n        bytes memory _signature\n    ) internal pure returns (address) {\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\n\n        return ecrecover(_ethSignedMessageHash, v, r, s);\n    }\n\n    function splitSignature(bytes memory sig) internal pure returns (bytes32 r_, bytes32 s_, uint8 v_) {\n        if (sig.length != 65) {\n            revert InvalidSignatureLength();\n        }\n\n        assembly {\n            /*\n            verbose explanation: https://ethereum.stackexchange.com/questions/135591/split-signature-function-in-solidity-by-example-docs\n            First 32 bytes stores the length of the signature\n            add(sig, 32) = pointer of sig + 32\n            effectively, skips first 32 bytes of signature\n            mload(p) loads next 32 bytes starting at the memory address p into memory\n            */\n\n            // first 32 bytes, after the length prefix\n            r_ := mload(add(sig, 32))\n            // second 32 bytes\n            s_ := mload(add(sig, 64))\n            // final byte (first byte of the next 32 bytes)\n            v_ := byte(0, mload(add(sig, 96)))\n        }\n\n        // implicitly return (r, s, v)\n    }\n\n    function getSocMessageHash(bytes32 _identifier, bytes32 _chunkAddr) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_identifier, _chunkAddr));\n    }\n\n    function socVerify(\n        address _signer, // signer Ethereum address to check against\n        bytes memory _signature,\n        bytes32 _identifier,\n        bytes32 _chunkAddr\n    ) internal pure returns (bool) {\n        bytes32 messageHash = getSocMessageHash(_identifier, _chunkAddr);\n        bytes32 ethMessageHash = getEthSignedMessageHash(messageHash);\n\n        return recoverSigner(ethMessageHash, _signature) == _signer;\n    }\n}\n"
    },
    "src/Util/TransformedChunkProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nlibrary TransformedBMTChunk {\n    // max chunk payload size\n    uint256 public constant MAX_CHUNK_PAYLOAD_SIZE = 4096;\n    // segment byte size\n    uint256 public constant SEGMENT_SIZE = 32;\n\n    /** Calculates the root hash from the provided inclusion proof segments and its corresponding segment index\n     * @param _proofSegments Proof segments.\n     * @param _proveSegment Segment to prove.\n     * @param _proveSegmentIndex Prove segment index\n     * @return _calculatedHash chunk hash\n     */\n    function transformedRootHashFromInclusionProof(\n        bytes32[] memory _proofSegments,\n        bytes32 _proveSegment,\n        uint256 _proveSegmentIndex,\n        bytes32 key\n    ) internal pure returns (bytes32 _calculatedHash) {\n        _calculatedHash = _proveSegment;\n        for (uint256 i = 0; i < _proofSegments.length; i++) {\n            bool mergeFromRight = _proveSegmentIndex % 2 == 0 ? true : false;\n            _calculatedHash = transformedMergeSegment(_calculatedHash, _proofSegments[i], mergeFromRight, key);\n            _proveSegmentIndex >>= 1;\n        }\n\n        return _calculatedHash;\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint64.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint64(uint64 _b) public pure returns (uint64) {\n        uint256 v = _b;\n\n        // swap bytes\n        v =\n            ((v >> 8) & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\n        // swap 2-byte long pairs\n        v =\n            ((v >> 16) & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\n        // swap 4-byte long pairs\n        v =\n            ((v >> 32) & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\n\n        return uint64(v);\n    }\n\n    /**\n     * Calculate the chunk address from the Binary Merkle Tree of the chunk data\n     *\n     * The BMT chunk address is the hash of the 8 byte span and the root\n     * hash of a binary Merkle tree (BMT) built on the 32-byte segments\n     * of the underlying data.\n     * @param _proofSegments Proof segments.\n     * @param _proveSegment Segment to prove.\n     * @param _proveSegmentIndex Prove segment index\n     * @param _chunkSpan chunk bytes length\n     * @return _chunkHash chunk hash\n     */\n    function transformedChunkAddressFromInclusionProof(\n        bytes32[] memory _proofSegments,\n        bytes32 _proveSegment,\n        uint256 _proveSegmentIndex,\n        uint64 _chunkSpan,\n        bytes32 key\n    ) internal pure returns (bytes32) {\n        bytes32 rootHash = transformedRootHashFromInclusionProof(\n            _proofSegments,\n            _proveSegment,\n            _proveSegmentIndex,\n            key\n        );\n        return keccak256(abi.encodePacked(key, reverseUint64(_chunkSpan), rootHash));\n    }\n\n    function transformedMergeSegment(\n        bytes32 _calculatedHash,\n        bytes32 _proofSegment,\n        bool mergeFromRight,\n        bytes32 key\n    ) internal pure returns (bytes32 res) {\n        if (mergeFromRight) {\n            res = keccak256(abi.encode(key, _calculatedHash, _proofSegment));\n        } else {\n            res = keccak256(abi.encode(key, _proofSegment, _calculatedHash));\n        }\n        return res;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}